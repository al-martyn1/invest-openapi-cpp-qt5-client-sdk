1) Подписки в streaming API

   https://tinkoffcreditsystems.github.io/invest-openapi/marketdata/

   ---------------------------------

   candle:subscribe
   {
       "event": "candle:subscribe",
       "figi": "{{FIGI}}",
       "interval": "{{INTERVAL}}"
   }

   Формат ответа:
       ...
       time string  Время в формате RFC3339Nano - так RFC3339Nano или ISO? Или это одно и то же?

   candle:unsubscribe
   {
       "event": "candle:unsubscribe",
       "figi": "{{FIGI}}",
       "interval": "{{INTERVAL}}"
   }

   ---------------------------------

   orderbook:subscribe
   {
       "event": "orderbook:subscribe",
       "figi": "{{FIGI}}",
       "depth": {{DEPTH}}
   }
   
   Формат ответа:
       ...
       time string  Время в формате RFC3339Nano - так RFC3339Nano или ISO? Или это одно и то же?

   orderbook:unsubscribe
   {
       "event": "orderbook:unsubscribe",
       "figi": "{{FIGI}}",
       "depth": {{DEPTH}}
   }

   ---------------------------------

   instrument_info:subscribe
   {
       "event": "instrument_info:subscribe",
       "figi": "{{FIGI}}"
   }

   instrument_info:unsubscribe
   {
       "event": "instrument_info:unsubscribe",
       "figi": "{{FIGI}}"
   }
      
   Пример ответа:
   {
       "event": "instrument_info",
       "time": "2019-08-07T15:35:00.029721253Z",
       "payload": {
           "figi": "BBG0013HGFT4",
           "trade_status": "normal_trading",
           "min_price_increment": 0.0025,
           "lot": 1000
       }
   }
   
   Не особо нужны, наверное. Может только, чтобы оперативно узнавать о приостановке торгов по инструменту
   
   Самое интересное - это стакан

   Итого в streaming API:
     candle
     orderbook
     instrument_info


2) Streaming данные по стакану приходят в таком виде (в одну строчку):
   {
     "payload":
       {
           "figi":"BBG004PYF2N3",
           "depth":20,
           "bids":[[1560,1],[1559.9,9],[1559.5,3],[1559.3,24],[1559.2,547],[1559.1,333],[1559,128],[1558.9,212],[1558.8,1],[1558.4,51],[1558.3,69],[1558,36],[1557.9,7],[1557.4,5],[1557.1,327],[1557,109],[1556.9,5],[1556.6,5],[1556,31],[1555.7,400]],
           "asks":[[1561.3,55],[1561.4,126],[1561.5,74],[1561.7,57],[1561.9,63],[1562,40],[1562.1,5],[1562.2,205],[1562.4,9],[1562.5,60],[1562.8,1],[1562.9,10],[1563,714],[1563.2,1],[1563.3,2],[1563.4,135],[1563.7,50],[1563.8,22],[1564,131],[1564.3,11]]
       },
     "event":"orderbook",
     "time":"2021-04-14T20:32:19.942941932Z"
   }

   Порядка 600-800 байт на одну посылку.
   2100 инструментов (примерно), 4 раза в секунду (а скорее раз в секунду или реже):
      2100*800*4 = 6 720 000 = ~7Мб/сек - прикинем, что 10Мб/сек, 
      но если раз в секунду - 2.5Мб/сек
      в мегабитах это 25-70

   Если торговать ограниченным набором инструментов (и держать руку на стакане по остальным)
   - это 100-200, наверное, итого от силы - 2.5-10.0 Мбит трафика


   По формату:

   bids/asks - выглядят, как массив OrderResponse
   payload   - выглядит похоже на Orderbook, но в Orderbook много лишнего

   Описывать на yaml'е и генерить - чо та лень, наверное руками сделаю.
   manual_models?


3) Начал разбираться со Streaming API - какого-то фуя bids/asks в стакане приходят в виде массива массивов.
   Из-за этого обычный тип Orderbook не получается использовать. Ну не мудаки ли?


4) 60 подписок на стакан - выдерживает
   Как протестировать больше?

   По каждому инструменту кладем время прихода в очередь (некоторого ограниченного размера). 
   Считаем средний интервал между поступлениями данных.
   По приходу любого сообщения пересчет среднего интервала? 
   Время берём от текущего момента, таким образом, если давно ничего не приходит,
   среднее всё равно вырастет.
   Надо посмотреть, как растёт задержка/пауза между приходом данных по инструменту
   в зависимости ответачисла подписок.
   Нужно для начала посмотреть средний период поступления данных, и зависит ли он от оличества подписок?
   На мобилке может быть, а на быстром проводном инете?

   Шпарим подписки с некоторой задержкой от нуля до максимального количества инструментов. 
   Размер задержки зависит от размера очереди для подсчёта среднего?
   Возмем их равными, хотя хз.

   Налабаю наверное на выходных, в ПН потестю.

5) Нужно ли при отписке от стакана по инструменту указывать глубину стакана? Если нужно, то - зачем?
   Похоже на баг в доке. Или в API

6) Можно ли в одном вебсокете подписываться на разные события?
   Вроде можно.

   Тогда исходный джейсон парсим на event/time/payload
   payload херачим как есть в QString, а по event'у - диспатчим.
   payload потом парсим, после диспечеризации.

   Или типа того.







