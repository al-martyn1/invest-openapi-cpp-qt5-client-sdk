/*! \file
    \brief Autogenerated file
 */

#pragma once

#include <QVector>
#include <QString>

#include "models.h"
#include "models_helpers.h"
#include "utility.h"

namespace invest_openapi
{

using namespace OpenAPI;


//----------------------------------------------------------------------------




//----------------------------------------------------------------------------
#ifndef INVEST_OPENAPI_GENERATED_MODEL_TO_STRINGS_DECLARED
#define INVEST_OPENAPI_GENERATED_MODEL_TO_STRINGS_DECLARED

QVector<QString> modelToStrings( const Empty                    &v );
QVector<QString> modelToStrings( const Error                    &v );
QVector<QString> modelToStrings( const UserAccount              &v );
QVector<QString> modelToStrings( const CurrencyPosition         &v );
QVector<QString> modelToStrings( const PortfolioPosition        &v );
QVector<QString> modelToStrings( const MoneyAmount              &v );
QVector<QString> modelToStrings( const Candle                   &v );
QVector<QString> modelToStrings( const OperationTrade           &v );
QVector<QString> modelToStrings( const Order                    &v );
QVector<QString> modelToStrings( const PlacedLimitOrder         &v );
QVector<QString> modelToStrings( const PlacedMarketOrder        &v );
QVector<QString> modelToStrings( const SandboxAccount           &v );
QVector<QString> modelToStrings( const SearchMarketInstrument   &v );
QVector<QString> modelToStrings( const MarketInstrument         &v );

#endif /* INVEST_OPENAPI_GENERATED_MODEL_TO_STRINGS_DECLARED */
//----------------------------------------------------------------------------




//----------------------------------------------------------------------------

template <> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< Empty                    >( const QString &nameOrPrefix, bool forInlining );
template <> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< Error                    >( const QString &nameOrPrefix, bool forInlining );
template <> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< UserAccount              >( const QString &nameOrPrefix, bool forInlining );
template <> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< CurrencyPosition         >( const QString &nameOrPrefix, bool forInlining );
template <> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< PortfolioPosition        >( const QString &nameOrPrefix, bool forInlining );
template <> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< MoneyAmount              >( const QString &nameOrPrefix, bool forInlining );
template <> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< Candle                   >( const QString &nameOrPrefix, bool forInlining );
template <> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< OperationTrade           >( const QString &nameOrPrefix, bool forInlining );
template <> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< Order                    >( const QString &nameOrPrefix, bool forInlining );
template <> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< PlacedLimitOrder         >( const QString &nameOrPrefix, bool forInlining );
template <> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< PlacedMarketOrder        >( const QString &nameOrPrefix, bool forInlining );
template <> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< SandboxAccount           >( const QString &nameOrPrefix, bool forInlining );
template <> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< SearchMarketInstrument   >( const QString &nameOrPrefix, bool forInlining );
template <> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< MarketInstrument         >( const QString &nameOrPrefix, bool forInlining );
//----------------------------------------------------------------------------



//----------------------------------------------------------------------------
#ifndef INVEST_OPENAPI_GENERATED_MODEL_TO_STRINGS_IMPLEMENTED
#define INVEST_OPENAPI_GENERATED_MODEL_TO_STRINGS_IMPLEMENTED


//----------------------------------------------------------------------------
//! Converts Empty to QVector of QString's 
inline QVector<QString> modelToStrings( const Empty &v )
{
    QVector<QString> resVec;

    //------------------------------
    if ( !v.is_tracking_id_Set() || !v.is_tracking_id_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getTrackingId() ) );

    //------------------------------
    if ( !v.is_payload_Set() || !v.is_payload_Valid() ) // type: object
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getPayload() ) );

    //------------------------------
    if ( !v.is_status_Set() || !v.is_status_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getStatus() ) );

    //------------------------------
    return resVec;
}

//----------------------------------------------------------------------------
//! Converts Error to QVector of QString's 
inline QVector<QString> modelToStrings( const Error &v )
{
    QVector<QString> resVec;

    //------------------------------
    if ( !v.is_tracking_id_Set() || !v.is_tracking_id_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getTrackingId() ) );

    //------------------------------
    if ( !v.is_status_Set() || !v.is_status_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getStatus() ) );

    //------------------------------
    if ( !v.is_payload_Set() || !v.is_payload_Valid() ) // type: object
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getPayload() ) );

    //------------------------------
    return resVec;
}

//----------------------------------------------------------------------------
//! Converts UserAccount to QVector of QString's 
inline QVector<QString> modelToStrings( const UserAccount &v )
{
    QVector<QString> resVec;

    //------------------------------
    if ( !v.is_broker_account_type_Set() || !v.is_broker_account_type_Valid() ) // type: BrokerAccountType
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getBrokerAccountType() ) );

    //------------------------------
    if ( !v.is_broker_account_id_Set() || !v.is_broker_account_id_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getBrokerAccountId() ) );

    //------------------------------
    return resVec;
}

//----------------------------------------------------------------------------
//! Converts CurrencyPosition to QVector of QString's 
inline QVector<QString> modelToStrings( const CurrencyPosition &v )
{
    QVector<QString> resVec;

    //------------------------------
    if ( !v.is_currency_Set() || !v.is_currency_Valid() ) // type: Currency
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getCurrency() ) );

    //------------------------------
    if ( !v.is_balance_Set() || !v.is_balance_Valid() ) // type: number
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getBalance() ) );

    //------------------------------
    if ( !v.is_blocked_Set() || !v.is_blocked_Valid() ) // type: number
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getBlocked() ) );

    //------------------------------
    return resVec;
}

//----------------------------------------------------------------------------
//! Converts PortfolioPosition to QVector of QString's 
inline QVector<QString> modelToStrings( const PortfolioPosition &v )
{
    QVector<QString> resVec;

    //------------------------------
    if ( !v.is_figi_Set() || !v.is_figi_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getFigi() ) );

    //------------------------------
    if ( !v.is_ticker_Set() || !v.is_ticker_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getTicker() ) );

    //------------------------------
    if ( !v.is_isin_Set() || !v.is_isin_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getIsin() ) );

    //------------------------------
    if ( !v.is_instrument_type_Set() || !v.is_instrument_type_Valid() ) // type: InstrumentType
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getInstrumentType() ) );

    //------------------------------
    if ( !v.is_balance_Set() || !v.is_balance_Valid() ) // type: number
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getBalance() ) );

    //------------------------------
    if ( !v.is_blocked_Set() || !v.is_blocked_Valid() ) // type: number
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getBlocked() ) );

    //------------------------------
    if ( !v.is_expected_yield_Set() || !v.is_expected_yield_Valid() ) // type: MoneyAmount
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getExpectedYield() ) );

    //------------------------------
    if ( !v.is_lots_Set() || !v.is_lots_Valid() ) // type: integer
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getLots() ) );

    //------------------------------
    if ( !v.is_average_position_price_Set() || !v.is_average_position_price_Valid() ) // type: MoneyAmount
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getAveragePositionPrice() ) );

    //------------------------------
    if ( !v.is_average_position_price_no_nkd_Set() || !v.is_average_position_price_no_nkd_Valid() ) // type: MoneyAmount
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getAveragePositionPriceNoNkd() ) );

    //------------------------------
    if ( !v.is_name_Set() || !v.is_name_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getName() ) );

    //------------------------------
    return resVec;
}

//----------------------------------------------------------------------------
//! Converts MoneyAmount to QVector of QString's 
inline QVector<QString> modelToStrings( const MoneyAmount &v )
{
    QVector<QString> resVec;

    //------------------------------
    if ( !v.is_currency_Set() || !v.is_currency_Valid() ) // type: Currency
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getCurrency() ) );

    //------------------------------
    if ( !v.is_value_Set() || !v.is_value_Valid() ) // type: number
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getValue() ) );

    //------------------------------
    return resVec;
}

//----------------------------------------------------------------------------
//! Converts Candle to QVector of QString's 
inline QVector<QString> modelToStrings( const Candle &v )
{
    QVector<QString> resVec;

    //------------------------------
    if ( !v.is_figi_Set() || !v.is_figi_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getFigi() ) );

    //------------------------------
    if ( !v.is_interval_Set() || !v.is_interval_Valid() ) // type: CandleResolution
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getInterval() ) );

    //------------------------------
    if ( !v.is_o_Set() || !v.is_o_Valid() ) // type: number
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getO() ) );

    //------------------------------
    if ( !v.is_c_Set() || !v.is_c_Valid() ) // type: number
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getC() ) );

    //------------------------------
    if ( !v.is_h_Set() || !v.is_h_Valid() ) // type: number
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getH() ) );

    //------------------------------
    if ( !v.is_l_Set() || !v.is_l_Valid() ) // type: number
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getL() ) );

    //------------------------------
    if ( !v.is_v_Set() || !v.is_v_Valid() ) // type: integer
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getV() ) );

    //------------------------------
    if ( !v.is_time_Set() || !v.is_time_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getTime() ) );

    //------------------------------
    return resVec;
}

//----------------------------------------------------------------------------
//! Converts OperationTrade to QVector of QString's 
inline QVector<QString> modelToStrings( const OperationTrade &v )
{
    QVector<QString> resVec;

    //------------------------------
    if ( !v.is_trade_id_Set() || !v.is_trade_id_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getTradeId() ) );

    //------------------------------
    if ( !v.is_date_Set() || !v.is_date_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getDate() ) );

    //------------------------------
    if ( !v.is_price_Set() || !v.is_price_Valid() ) // type: number
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getPrice() ) );

    //------------------------------
    if ( !v.is_quantity_Set() || !v.is_quantity_Valid() ) // type: integer
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getQuantity() ) );

    //------------------------------
    return resVec;
}

//----------------------------------------------------------------------------
//! Converts Order to QVector of QString's 
inline QVector<QString> modelToStrings( const Order &v )
{
    QVector<QString> resVec;

    //------------------------------
    if ( !v.is_order_id_Set() || !v.is_order_id_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getOrderId() ) );

    //------------------------------
    if ( !v.is_figi_Set() || !v.is_figi_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getFigi() ) );

    //------------------------------
    if ( !v.is_operation_Set() || !v.is_operation_Valid() ) // type: OperationType
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getOperation() ) );

    //------------------------------
    if ( !v.is_status_Set() || !v.is_status_Valid() ) // type: OrderStatus
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getStatus() ) );

    //------------------------------
    if ( !v.is_requested_lots_Set() || !v.is_requested_lots_Valid() ) // type: integer
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getRequestedLots() ) );

    //------------------------------
    if ( !v.is_executed_lots_Set() || !v.is_executed_lots_Valid() ) // type: integer
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getExecutedLots() ) );

    //------------------------------
    if ( !v.is_type_Set() || !v.is_type_Valid() ) // type: OrderType
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getType() ) );

    //------------------------------
    if ( !v.is_price_Set() || !v.is_price_Valid() ) // type: number
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getPrice() ) );

    //------------------------------
    return resVec;
}

//----------------------------------------------------------------------------
//! Converts PlacedLimitOrder to QVector of QString's 
inline QVector<QString> modelToStrings( const PlacedLimitOrder &v )
{
    QVector<QString> resVec;

    //------------------------------
    if ( !v.is_order_id_Set() || !v.is_order_id_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getOrderId() ) );

    //------------------------------
    if ( !v.is_operation_Set() || !v.is_operation_Valid() ) // type: OperationType
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getOperation() ) );

    //------------------------------
    if ( !v.is_status_Set() || !v.is_status_Valid() ) // type: OrderStatus
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getStatus() ) );

    //------------------------------
    if ( !v.is_reject_reason_Set() || !v.is_reject_reason_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getRejectReason() ) );

    //------------------------------
    if ( !v.is_message_Set() || !v.is_message_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getMessage() ) );

    //------------------------------
    if ( !v.is_requested_lots_Set() || !v.is_requested_lots_Valid() ) // type: integer
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getRequestedLots() ) );

    //------------------------------
    if ( !v.is_executed_lots_Set() || !v.is_executed_lots_Valid() ) // type: integer
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getExecutedLots() ) );

    //------------------------------
    if ( !v.is_commission_Set() || !v.is_commission_Valid() ) // type: MoneyAmount
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getCommission() ) );

    //------------------------------
    return resVec;
}

//----------------------------------------------------------------------------
//! Converts PlacedMarketOrder to QVector of QString's 
inline QVector<QString> modelToStrings( const PlacedMarketOrder &v )
{
    QVector<QString> resVec;

    //------------------------------
    if ( !v.is_order_id_Set() || !v.is_order_id_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getOrderId() ) );

    //------------------------------
    if ( !v.is_operation_Set() || !v.is_operation_Valid() ) // type: OperationType
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getOperation() ) );

    //------------------------------
    if ( !v.is_status_Set() || !v.is_status_Valid() ) // type: OrderStatus
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getStatus() ) );

    //------------------------------
    if ( !v.is_reject_reason_Set() || !v.is_reject_reason_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getRejectReason() ) );

    //------------------------------
    if ( !v.is_message_Set() || !v.is_message_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getMessage() ) );

    //------------------------------
    if ( !v.is_requested_lots_Set() || !v.is_requested_lots_Valid() ) // type: integer
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getRequestedLots() ) );

    //------------------------------
    if ( !v.is_executed_lots_Set() || !v.is_executed_lots_Valid() ) // type: integer
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getExecutedLots() ) );

    //------------------------------
    if ( !v.is_commission_Set() || !v.is_commission_Valid() ) // type: MoneyAmount
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getCommission() ) );

    //------------------------------
    return resVec;
}

//----------------------------------------------------------------------------
//! Converts SandboxAccount to QVector of QString's 
inline QVector<QString> modelToStrings( const SandboxAccount &v )
{
    QVector<QString> resVec;

    //------------------------------
    if ( !v.is_broker_account_type_Set() || !v.is_broker_account_type_Valid() ) // type: BrokerAccountType
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getBrokerAccountType() ) );

    //------------------------------
    if ( !v.is_broker_account_id_Set() || !v.is_broker_account_id_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getBrokerAccountId() ) );

    //------------------------------
    return resVec;
}

//----------------------------------------------------------------------------
//! Converts SearchMarketInstrument to QVector of QString's 
inline QVector<QString> modelToStrings( const SearchMarketInstrument &v )
{
    QVector<QString> resVec;

    //------------------------------
    if ( !v.is_figi_Set() || !v.is_figi_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getFigi() ) );

    //------------------------------
    if ( !v.is_ticker_Set() || !v.is_ticker_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getTicker() ) );

    //------------------------------
    if ( !v.is_isin_Set() || !v.is_isin_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getIsin() ) );

    //------------------------------
    if ( !v.is_min_price_increment_Set() || !v.is_min_price_increment_Valid() ) // type: number
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getMinPriceIncrement() ) );

    //------------------------------
    if ( !v.is_lot_Set() || !v.is_lot_Valid() ) // type: integer
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getLot() ) );

    //------------------------------
    if ( !v.is_currency_Set() || !v.is_currency_Valid() ) // type: Currency
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getCurrency() ) );

    //------------------------------
    if ( !v.is_name_Set() || !v.is_name_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getName() ) );

    //------------------------------
    if ( !v.is_type_Set() || !v.is_type_Valid() ) // type: InstrumentType
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getType() ) );

    //------------------------------
    return resVec;
}

//----------------------------------------------------------------------------
//! Converts MarketInstrument to QVector of QString's 
inline QVector<QString> modelToStrings( const MarketInstrument &v )
{
    QVector<QString> resVec;

    //------------------------------
    if ( !v.is_figi_Set() || !v.is_figi_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getFigi() ) );

    //------------------------------
    if ( !v.is_ticker_Set() || !v.is_ticker_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getTicker() ) );

    //------------------------------
    if ( !v.is_isin_Set() || !v.is_isin_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getIsin() ) );

    //------------------------------
    if ( !v.is_min_price_increment_Set() || !v.is_min_price_increment_Valid() ) // type: number
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getMinPriceIncrement() ) );

    //------------------------------
    if ( !v.is_lot_Set() || !v.is_lot_Valid() ) // type: integer
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getLot() ) );

    //------------------------------
    if ( !v.is_min_quantity_Set() || !v.is_min_quantity_Valid() ) // type: integer
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getMinQuantity() ) );

    //------------------------------
    if ( !v.is_currency_Set() || !v.is_currency_Valid() ) // type: Currency
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getCurrency() ) );

    //------------------------------
    if ( !v.is_name_Set() || !v.is_name_Valid() ) // type: string
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getName() ) );

    //------------------------------
    if ( !v.is_type_Set() || !v.is_type_Valid() ) // type: InstrumentType
        appendToStringVector(resVec, QString());
    else
        appendToStringVector(resVec, modelToStrings( v.getType() ) );

    //------------------------------
    return resVec;
}

#endif /* INVEST_OPENAPI_GENERATED_MODEL_TO_STRINGS_IMPLEMENTED */
//----------------------------------------------------------------------------










//----------------------------------------------------------------------------
//! Creates SQL schema format for 'Empty' model 
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< Empty >( const QString &nameOrPrefix, bool forInlining )
{
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TRACKING_ID"                      , "VARCHAR(255)"                     ); // Spec ::schema::Empty::before::trackingId
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "PAYLOAD"                          , ""                                 ); // Spec ::schema::Empty::before::payload
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "STATUS"                           , "VARCHAR(255)"                     ); // Spec ::schema::Empty::before::status

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();
}

//----------------------------------------------------------------------------
//! Creates SQL schema format for 'Error' model 
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< Error >( const QString &nameOrPrefix, bool forInlining )
{
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TRACKING_ID"                      , "VARCHAR(255)"                     ); // Spec ::schema::Error::before::trackingId
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "STATUS"                           , "VARCHAR(255)"                     ); // Spec ::schema::Error::before::status
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "PAYLOAD"                          , ""                                 ); // Spec ::schema::Error::before::payload

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();
}

//----------------------------------------------------------------------------
//! Creates SQL schema format for 'UserAccount' model 
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< UserAccount >( const QString &nameOrPrefix, bool forInlining )
{
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<BrokerAccountType>( generateFieldNameFromPrefixAndName( p , "BROKER_ACCOUNT_TYPE" ), true ) ); // brokerAccountType
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "BROKER_ACCOUNT_ID"                , "VARCHAR(255)"                     ); // Spec ::schema::UserAccount::before::brokerAccountId

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();
}

//----------------------------------------------------------------------------
//! Creates SQL schema format for 'CurrencyPosition' model 
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< CurrencyPosition >( const QString &nameOrPrefix, bool forInlining )
{
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<Currency>( generateFieldNameFromPrefixAndName( p , "CURRENCY" ), true ) ); // currency
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "BALANCE"                          , "DECIMAL(18,8)"                    ); // Spec ::schema::CurrencyPosition::before::balance
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "BLOCKED"                          , "DECIMAL(18,8)"                    ); // Spec ::schema::CurrencyPosition::before::blocked

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();
}

//----------------------------------------------------------------------------
//! Creates SQL schema format for 'PortfolioPosition' model 
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< PortfolioPosition >( const QString &nameOrPrefix, bool forInlining )
{
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "FIGI"                             , "VARCHAR(12)"                      ); // Spec ::schema::PortfolioPosition::before::figi
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TICKER"                           , "VARCHAR(12)"                      ); // Spec ::schema::PortfolioPosition::before::ticker
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ISIN"                             , "VARCHAR(12)"                      ); // Spec ::schema::PortfolioPosition::before::isin
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<InstrumentType>( generateFieldNameFromPrefixAndName( p , "INSTRUMENT_TYPE" ), true ) ); // instrumentType
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "BALANCE"                          , "DECIMAL(18,8)"                    ); // Spec ::schema::PortfolioPosition::before::balance
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "BLOCKED"                          , "DECIMAL(18,8)"                    ); // Spec ::schema::PortfolioPosition::before::blocked
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<MoneyAmount>( generateFieldNameFromPrefixAndName( p , "EXPECTED_YIELD_MONEY_AMOUNT" ), true ) ); // expectedYield
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "LOTS"                             , "INTEGER"                          ); // Spec ::schema::PortfolioPosition::before::lots
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<MoneyAmount>( generateFieldNameFromPrefixAndName( p , "AVERAGE_POSITION_PRICE_MONEY_AMOUNT" ), true ) ); // averagePositionPrice
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<MoneyAmount>( generateFieldNameFromPrefixAndName( p , "AVERAGE_POSITION_PRICE_NO_NKD_MONEY_AMOUNT" ), true ) ); // averagePositionPriceNoNkd
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "NAME"                             , "VARCHAR(255)"                     ); // Spec ::schema::PortfolioPosition::before::name

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();
}

//----------------------------------------------------------------------------
//! Creates SQL schema format for 'MoneyAmount' model 
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< MoneyAmount >( const QString &nameOrPrefix, bool forInlining )
{
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<Currency>( generateFieldNameFromPrefixAndName( p , "CURRENCY" ), true ) ); // currency
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "VALUE"                            , "DECIMAL(18,8)"                    ); // Spec ::schema::MoneyAmount::before::value

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();
}

//----------------------------------------------------------------------------
//! Creates SQL schema format for 'Candle' model 
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< Candle >( const QString &nameOrPrefix, bool forInlining )
{
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "FIGI"                             , "VARCHAR(12)"                      ); // Spec ::schema::Candle::before::figi
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<CandleResolution>( generateFieldNameFromPrefixAndName( p , "INTERVAL_CANDLE_RESOLUTION" ), true ) ); // interval
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "O"                                , "DECIMAL(18,8)"                    ); // Spec ::schema::Candle::before::o
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "C"                                , "DECIMAL(18,8)"                    ); // Spec ::schema::Candle::before::c
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "H"                                , "DECIMAL(18,8)"                    ); // Spec ::schema::Candle::before::h
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "L"                                , "DECIMAL(18,8)"                    ); // Spec ::schema::Candle::before::l
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "V"                                , "INTEGER"                          ); // Spec ::schema::Candle::before::v
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TIME"                             , "VARCHAR(255)"                     ); // Spec ::schema::Candle::before::time

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();
}

//----------------------------------------------------------------------------
//! Creates SQL schema format for 'OperationTrade' model 
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< OperationTrade >( const QString &nameOrPrefix, bool forInlining )
{
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TRADE_ID"                         , "VARCHAR(255)"                     ); // Spec ::schema::OperationTrade::before::tradeId
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "DATE"                             , "VARCHAR(255)"                     ); // Spec ::schema::OperationTrade::before::date
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "PRICE"                            , "DECIMAL(18,8)"                    ); // Spec ::schema::OperationTrade::before::price
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "QUANTITY"                         , "INTEGER"                          ); // Spec ::schema::OperationTrade::before::quantity

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();
}

//----------------------------------------------------------------------------
//! Creates SQL schema format for 'Order' model 
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< Order >( const QString &nameOrPrefix, bool forInlining )
{
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ORDER_ID"                         , "VARCHAR(32) NOT NULL UNIQUE"      ); // Spec ::schema::Order::before::orderId
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "FIGI"                             , "VARCHAR(12)"                      ); // Spec ::schema::Order::before::figi
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<OperationType>( generateFieldNameFromPrefixAndName( p , "OPERATION_TYPE" ), true ) ); // operation
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<OrderStatus>( generateFieldNameFromPrefixAndName( p , "ORDER_STATUS" ), true ) ); // status
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "REQUESTED_LOTS"                   , "INTEGER"                          ); // Spec ::schema::Order::before::requestedLots
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "EXECUTED_LOTS"                    , "INTEGER"                          ); // Spec ::schema::Order::before::executedLots
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<OrderType>( generateFieldNameFromPrefixAndName( p , "ORDER_TYPE" ), true ) ); // type
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "PRICE"                            , "DECIMAL(18,8)"                    ); // Spec ::schema::Order::before::price

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();
}

//----------------------------------------------------------------------------
//! Creates SQL schema format for 'PlacedLimitOrder' model 
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< PlacedLimitOrder >( const QString &nameOrPrefix, bool forInlining )
{
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ORDER_ID"                         , "VARCHAR(255)"                     ); // Spec ::schema::PlacedLimitOrder::before::orderId
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<OperationType>( generateFieldNameFromPrefixAndName( p , "OPERATION_TYPE" ), true ) ); // operation
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<OrderStatus>( generateFieldNameFromPrefixAndName( p , "ORDER_STATUS" ), true ) ); // status
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "REJECT_REASON"                    , "VARCHAR(255)"                     ); // Spec ::schema::PlacedLimitOrder::before::rejectReason
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "MESSAGE"                          , "VARCHAR(255)"                     ); // Spec ::schema::PlacedLimitOrder::before::message
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "REQUESTED_LOTS"                   , "INTEGER"                          ); // Spec ::schema::PlacedLimitOrder::before::requestedLots
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "EXECUTED_LOTS"                    , "INTEGER"                          ); // Spec ::schema::PlacedLimitOrder::before::executedLots
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<MoneyAmount>( generateFieldNameFromPrefixAndName( p , "COMMISSION_MONEY_AMOUNT" ), true ) ); // commission

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();
}

//----------------------------------------------------------------------------
//! Creates SQL schema format for 'PlacedMarketOrder' model 
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< PlacedMarketOrder >( const QString &nameOrPrefix, bool forInlining )
{
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ORDER_ID"                         , "VARCHAR(255)"                     ); // Spec ::schema::PlacedMarketOrder::before::orderId
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<OperationType>( generateFieldNameFromPrefixAndName( p , "OPERATION_TYPE" ), true ) ); // operation
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<OrderStatus>( generateFieldNameFromPrefixAndName( p , "ORDER_STATUS" ), true ) ); // status
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "REJECT_REASON"                    , "VARCHAR(255)"                     ); // Spec ::schema::PlacedMarketOrder::before::rejectReason
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "MESSAGE"                          , "VARCHAR(255)"                     ); // Spec ::schema::PlacedMarketOrder::before::message
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "REQUESTED_LOTS"                   , "INTEGER"                          ); // Spec ::schema::PlacedMarketOrder::before::requestedLots
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "EXECUTED_LOTS"                    , "INTEGER"                          ); // Spec ::schema::PlacedMarketOrder::before::executedLots
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<MoneyAmount>( generateFieldNameFromPrefixAndName( p , "COMMISSION_MONEY_AMOUNT" ), true ) ); // commission

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();
}

//----------------------------------------------------------------------------
//! Creates SQL schema format for 'SandboxAccount' model 
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< SandboxAccount >( const QString &nameOrPrefix, bool forInlining )
{
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<BrokerAccountType>( generateFieldNameFromPrefixAndName( p , "BROKER_ACCOUNT_TYPE" ), true ) ); // brokerAccountType
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "BROKER_ACCOUNT_ID"                , "VARCHAR(255)"                     ); // Spec ::schema::SandboxAccount::before::brokerAccountId

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();
}

//----------------------------------------------------------------------------
//! Creates SQL schema format for 'SearchMarketInstrument' model 
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< SearchMarketInstrument >( const QString &nameOrPrefix, bool forInlining )
{
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "FIGI"                             , "VARCHAR(12)"                      ); // Spec ::schema::SearchMarketInstrument::before::figi
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TICKER"                           , "VARCHAR(12)"                      ); // Spec ::schema::SearchMarketInstrument::before::ticker
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ISIN"                             , "VARCHAR(12)"                      ); // Spec ::schema::SearchMarketInstrument::before::isin
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "MIN_PRICE_INCREMENT"              , "DECIMAL(18,8)"                    ); // Spec ::schema::SearchMarketInstrument::before::minPriceIncrement
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "LOT"                              , "INTEGER"                          ); // Spec ::schema::SearchMarketInstrument::before::lot
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<Currency>( generateFieldNameFromPrefixAndName( p , "CURRENCY" ), true ) ); // currency
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "NAME"                             , "VARCHAR(255)"                     ); // Spec ::schema::SearchMarketInstrument::before::name
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<InstrumentType>( generateFieldNameFromPrefixAndName( p , "INSTRUMENT_TYPE" ), true ) ); // type

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();
}

//----------------------------------------------------------------------------
//! Creates SQL schema format for 'MarketInstrument' model 
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE< MarketInstrument >( const QString &nameOrPrefix, bool forInlining )
{
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_BEGIN() /* if (forInlining) */
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"                               , "INTEGER REFERENCES MARKET_INSTRUMENT" ); // ID spec inline
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "FIGI"                             , "VARCHAR(12) NOT NULL UNIQUE"      ); // Spec ::schema::MarketInstrument::before::figi
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TICKER"                           , "VARCHAR(12) NOT NULL UNIQUE"      ); // Spec ::schema::MarketInstrument::before::ticker
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_ELSE()
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"                               , "INTEGER PRIMARY KEY AUTOINCREMENT" ); // ID spec schema
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "FIGI"                             , "VARCHAR(12) NOT NULL UNIQUE"      ); // Spec ::schema::MarketInstrument::before::figi
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TICKER"                           , "VARCHAR(12) NOT NULL UNIQUE"      ); // Spec ::schema::MarketInstrument::before::ticker
    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_END()
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ISIN"                             , "VARCHAR(12) UNIQUE"               ); // Spec ::schema::MarketInstrument::before::isin
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "MIN_PRICE_INCREMENT"              , "DECIMAL(18,8)"                    ); // Spec ::schema::MarketInstrument::before::minPriceIncrement
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "LOT"                              , "INTEGER"                          ); // Spec ::schema::MarketInstrument::before::lot
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "LOT_MARKET"                       , "INTEGER"                          ); // Spec ::schema::MarketInstrument::before::lot
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "MIN_QUANTITY"                     , "INTEGER"                          ); // Spec ::schema::MarketInstrument::before::minQuantity
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<Currency>( generateFieldNameFromPrefixAndName( p , "CURRENCY" ), true ) ); // currency
        IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "NAME"                             , "VARCHAR(255)"                     ); // Spec ::schema::MarketInstrument::before::name
        appendToStringVector( resVec, modelMakeSqlSchemaStringVector_SQLITE<InstrumentType>( generateFieldNameFromPrefixAndName( p , "INSTRUMENT_TYPE" ), true ) ); // type

    IOA_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();
}


inline QMap<QString,QString> modelMakeAllSqlSchemas_SQLITE()
{
    QMap<QString,QString> resMap;

    resMap[ "EMPTY"                    ]  = modelMakeSqlCreateTableSchema_SQLITE( modelMakeSqlSchemaStringVector_SQLITE< Empty                  >( QString(), false ) ); 
    resMap[ "ERROR"                    ]  = modelMakeSqlCreateTableSchema_SQLITE( modelMakeSqlSchemaStringVector_SQLITE< Error                  >( QString(), false ) ); 
    resMap[ "USER_ACCOUNT"             ]  = modelMakeSqlCreateTableSchema_SQLITE( modelMakeSqlSchemaStringVector_SQLITE< UserAccount            >( QString(), false ) ); 
    resMap[ "CURRENCY_POSITION"        ]  = modelMakeSqlCreateTableSchema_SQLITE( modelMakeSqlSchemaStringVector_SQLITE< CurrencyPosition       >( QString(), false ) ); 
    resMap[ "PORTFOLIO_POSITION"       ]  = modelMakeSqlCreateTableSchema_SQLITE( modelMakeSqlSchemaStringVector_SQLITE< PortfolioPosition      >( QString(), false ) ); 
    resMap[ "MONEY_AMOUNT"             ]  = modelMakeSqlCreateTableSchema_SQLITE( modelMakeSqlSchemaStringVector_SQLITE< MoneyAmount            >( QString(), false ) ); 
    resMap[ "CANDLE"                   ]  = modelMakeSqlCreateTableSchema_SQLITE( modelMakeSqlSchemaStringVector_SQLITE< Candle                 >( QString(), false ) ); 
    resMap[ "OPERATION_TRADE"          ]  = modelMakeSqlCreateTableSchema_SQLITE( modelMakeSqlSchemaStringVector_SQLITE< OperationTrade         >( QString(), false ) ); 
    resMap[ "ORDER"                    ]  = modelMakeSqlCreateTableSchema_SQLITE( modelMakeSqlSchemaStringVector_SQLITE< Order                  >( QString(), false ) ); 
    resMap[ "PLACED_LIMIT_ORDER"       ]  = modelMakeSqlCreateTableSchema_SQLITE( modelMakeSqlSchemaStringVector_SQLITE< PlacedLimitOrder       >( QString(), false ) ); 
    resMap[ "PLACED_MARKET_ORDER"      ]  = modelMakeSqlCreateTableSchema_SQLITE( modelMakeSqlSchemaStringVector_SQLITE< PlacedMarketOrder      >( QString(), false ) ); 
    resMap[ "SANDBOX_ACCOUNT"          ]  = modelMakeSqlCreateTableSchema_SQLITE( modelMakeSqlSchemaStringVector_SQLITE< SandboxAccount         >( QString(), false ) ); 
    resMap[ "SEARCH_MARKET_INSTRUMENT" ]  = modelMakeSqlCreateTableSchema_SQLITE( modelMakeSqlSchemaStringVector_SQLITE< SearchMarketInstrument >( QString(), false ) ); 
    resMap[ "MARKET_INSTRUMENT"        ]  = modelMakeSqlCreateTableSchema_SQLITE( modelMakeSqlSchemaStringVector_SQLITE< MarketInstrument       >( QString(), false ) ); 

    return resMap;
}




inline QSet<QString> modelMakeAllSqlTablesSet_SQLITE()
{
    QSet<QString> resSet;

    resSet.insert( "EMPTY"                    );
    resSet.insert( "ERROR"                    );
    resSet.insert( "USER_ACCOUNT"             );
    resSet.insert( "CURRENCY_POSITION"        );
    resSet.insert( "PORTFOLIO_POSITION"       );
    resSet.insert( "MONEY_AMOUNT"             );
    resSet.insert( "CANDLE"                   );
    resSet.insert( "OPERATION_TRADE"          );
    resSet.insert( "ORDER"                    );
    resSet.insert( "PLACED_LIMIT_ORDER"       );
    resSet.insert( "PLACED_MARKET_ORDER"      );
    resSet.insert( "SANDBOX_ACCOUNT"          );
    resSet.insert( "SEARCH_MARKET_INSTRUMENT" );
    resSet.insert( "MARKET_INSTRUMENT"        );

    return resSet;
}


} // namespace invest_openapi


