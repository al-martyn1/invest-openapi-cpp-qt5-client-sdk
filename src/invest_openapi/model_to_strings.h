/*! \file
    \brief Autogenerated file
 */

#pragma once

#include <QVector>
#include <QString>

#include "models.h"
#include "models_helpers.h"
#include "utility.h"
#include "cpp/cpp.h"


namespace invest_openapi
{


using namespace OpenAPI;



//----------------------------------------------------------------------------
template <typename ModelType> QVector<QString> modelMakeSqlSchemaStringVector_SQLITE( const QString &nameOrPrefix, bool forInlining );


inline QString modelMakeSqlCreateTableSchema_SQLITE( const QVector<QString> &sqlSchema )
{
    return QString("  ") + mergeString( sqlSchema, "\r\n, "  );
}


//----------------------------------------------------------------------------
inline void appendToStringVector( QVector<QString> &vec, const QString &v )
{
    vec.append(v);
}

//----------------------------------------------------------------------------
inline void appendToStringVector( QVector<QString> &vec, const QVector<QString> &v )
{
    vec.append(v);
}

//----------------------------------------------------------------------------
inline QVector<QString> modelToStrings( const QString &s )
{
    QVector<QString> resVec;
    appendToStringVector( resVec, s );
    return resVec;
}

//----------------------------------------------------------------------------
inline QVector<QString> modelToStrings( const QVector<QString> &v )
{
    return v;
}

//----------------------------------------------------------------------------
inline QVector<QString> modelToStrings( const marty::Decimal &v )
{
    return modelToStrings( QString::fromStdString( marty::toString(v) ) );
}

//----------------------------------------------------------------------------
inline QVector<QString> modelToStrings( const Object &v )
{
    if ( v.isValid() && v.isSet() )
       return modelToStrings( v.asJson() );
    else
       return modelToStrings( QString() );
}

/*
inline QVector<QString> modelToStrings( const Empty &v )
{
    return modelToStrings( QString::fromStdString( marty::toString(v) ) );
}
*/
//----------------------------------------------------------------------------




//----------------------------------------------------------------------------
inline
QVector<QString> modelsHelperStringToVector( const QString &s )
{
    QVector<QString> resVec;
    appendToStringVector( resVec, s );
    return resVec;
}

inline
QVector<QString> modelsHelperStringToVector( const QString &s1, const QString &s2 )
{
    QVector<QString> resVec;
    appendToStringVector( resVec, s1 );
    appendToStringVector( resVec, s2 );
    return resVec;
}

inline
QVector<QString> modelsHelperStringToVector( const QString &s1, const QString &s2, const QString &s3 )
{
    QVector<QString> resVec;
    appendToStringVector( resVec, s1 );
    appendToStringVector( resVec, s2 );
    appendToStringVector( resVec, s3 );
    return resVec;
}

inline
QVector<QString> modelsHelperStringToVector( const QString &s1, const QString &s2, const QString &s3, const QString &s4 )
{
    QVector<QString> resVec;
    appendToStringVector( resVec, s1 );
    appendToStringVector( resVec, s2 );
    appendToStringVector( resVec, s3 );
    appendToStringVector( resVec, s4 );
    return resVec;
}

inline
QVector<QString> modelsHelperStringToVector( const QString &s1, const QString &s2, const QString &s3, const QString &s4, const QString &s5 )
{
    QVector<QString> resVec;
    appendToStringVector( resVec, s1 );
    appendToStringVector( resVec, s2 );
    appendToStringVector( resVec, s3 );
    appendToStringVector( resVec, s4 );
    appendToStringVector( resVec, s5 );
    return resVec;
}


inline QVector<QString> modelsHelperStringToVector( const std::string &s ) 
{ return modelsHelperStringToVector( QString::fromStdString(s) ); }

inline QVector<QString> modelsHelperStringToVector( const std::string &s1, const std::string &s2 )
{ return modelsHelperStringToVector( QString::fromStdString(s1), QString::fromStdString(s2) ); }

inline QVector<QString> modelsHelperStringToVector( const std::string &s1, const std::string &s2, const std::string &s3 )
{ return modelsHelperStringToVector( QString::fromStdString(s1), QString::fromStdString(s2), QString::fromStdString(s3) ); }

inline QVector<QString> modelsHelperStringToVector( const std::string &s1, const std::string &s2, const std::string &s3, const std::string &s4 )
{ return modelsHelperStringToVector( QString::fromStdString(s1), QString::fromStdString(s2), QString::fromStdString(s3), QString::fromStdString(s4) ); }

inline QVector<QString> modelsHelperStringToVector( const std::string &s1, const std::string &s2, const std::string &s3, const std::string &s4, const std::string &s5 )
{ return modelsHelperStringToVector( QString::fromStdString(s1), QString::fromStdString(s2), QString::fromStdString(s3), QString::fromStdString(s4), QString::fromStdString(s5) ); }

//----------------------------------------------------------------------------
inline QVector<QString> modelsHelperStringToVector( const char* s ) 
{ return modelsHelperStringToVector( QString::fromLocal8Bit(s) ); }

inline QVector<QString> modelsHelperStringToVector( const char* s1, const char* s2 )
{ return modelsHelperStringToVector( QString::fromLocal8Bit(s1), QString::fromLocal8Bit(s2) ); }

inline QVector<QString> modelsHelperStringToVector( const char* s1, const char* s2, const char* s3 )
{ return modelsHelperStringToVector( QString::fromLocal8Bit(s1), QString::fromLocal8Bit(s2), QString::fromLocal8Bit(s3) ); }

inline QVector<QString> modelsHelperStringToVector( const char* s1, const char* s2, const char* s3, const char* s4 )
{ return modelsHelperStringToVector( QString::fromLocal8Bit(s1), QString::fromLocal8Bit(s2), QString::fromLocal8Bit(s3), QString::fromLocal8Bit(s4) ); }

inline QVector<QString> modelsHelperStringToVector( const char* s1, const char* s2, const char* s3, const char* s4, const char* s5 )
{ return modelsHelperStringToVector( QString::fromLocal8Bit(s1), QString::fromLocal8Bit(s2), QString::fromLocal8Bit(s3), QString::fromLocal8Bit(s4), QString::fromLocal8Bit(s5) ); }

//----------------------------------------------------------------------------




//----------------------------------------------------------------------------
template< class CharT, class Traits = std::char_traits<CharT>, class Allocator = std::allocator<CharT> >
inline
std::basic_string< CharT, Traits, Allocator > generateFieldName( std::basic_string< CharT, Traits, Allocator > prefix, const std::basic_string< CharT, Traits, Allocator > &fieldName )
{
    // using namespace cpp;

    prefix = cpp::trimUnderscoresTrailing( prefix );

    if (prefix.empty())
        return fieldName;

    cpp::NameStyle nsPrefixStyle    = cpp::detectNameStyle(prefix);
    cpp::NameStyle nsFieldNameStyle = cpp::detectNameStyle(fieldName);

    // remove leading and traling underscores
    nsPrefixStyle    = cpp::getNameStyleBuddy(nsPrefixStyle   , false /* !underlinedBuddy */ );
    nsFieldNameStyle = cpp::getNameStyleBuddy(nsFieldNameStyle, false /* !underlinedBuddy */ );

    std::basic_string< CharT, Traits, Allocator > nswFormattedPrefix         = cpp::formatName( prefix   , nsPrefixStyle    );
    std::basic_string< CharT, Traits, Allocator > nswFormattedFieldNameStyle = cpp::formatName( fieldName, nsFieldNameStyle );

    if (ends_with( nswFormattedPrefix, nswFormattedFieldNameStyle))
        return prefix;

    //if (prefix[prefix.size()-1]=='_')
    //    return cpp::formatName(prefix + fieldName, cpp::NameStyle::sqlUnderscoredStyle);
    
    return cpp::formatName(prefix + std::basic_string< CharT, Traits, Allocator >(1,(CharT)'_') + fieldName, cpp::NameStyle::sqlUnderscoredStyle);
}

//----------------------------------------------------------------------------
inline
QString generateFieldName( const QString &prefix, const QString &fieldName )
{
    return QString::fromStdWString( generateFieldName( prefix.toStdWString(), fieldName.toStdWString() ) );
}

//----------------------------------------------------------------------------




//----------------------------------------------------------------------------
template <typename ModelType> 
inline 
QVector<QString> modelToStringsConvertHelper( const ModelType &m )
{
    return modelsHelperStringToVector( m.asJson() );
}

//------------------------------
template <typename ModelType> 
inline 
QVector<QString> modelToStringsConvertHelper2( const ModelType &m )
{
    return modelsHelperStringToVector( QString("%1").arg( (unsigned)m.getValue() )
                         , m.asJson() 
                         );
}

//----------------------------------------------------------------------------




//----------------------------------------------------------------------------
inline QVector<QString> modelToStrings( const QDateTime         &v ) { return modelToStrings( formatDateTimeISO8601(v) ); }
inline QVector<QString> modelToStrings( const BrokerAccountType &v ) { return modelToStringsConvertHelper2(v); }
inline QVector<QString> modelToStrings( const Currency          &v ) { return modelToStringsConvertHelper2(v); }
inline QVector<QString> modelToStrings( const InstrumentType    &v ) { return modelToStringsConvertHelper2(v); }
inline QVector<QString> modelToStrings( const CandleResolution  &v ) { return modelToStringsConvertHelper2(v); }
inline QVector<QString> modelToStrings( const OperationType     &v ) { return modelToStringsConvertHelper2(v); }
inline QVector<QString> modelToStrings( const OrderStatus       &v ) { return modelToStringsConvertHelper2(v); }
inline QVector<QString> modelToStrings( const OrderType         &v ) { return modelToStringsConvertHelper2(v); }

//----------------------------------------------------------------------------
template< typename ModelType > inline 
QVector<QString> modelTableGetColumnNames( const QString &prefix )
{
    return modelsHelperStringToVector( QString() );
}

template< > inline QVector<QString> modelTableGetColumnNames< BrokerAccountType >( const QString &prefix )   { return modelsHelperStringToVector( generateFieldName(prefix,"ID"), generateFieldName(prefix,"TYPE"      ) , generateFieldName(prefix,"DESCRIPTION") ); }
template< > inline QVector<QString> modelTableGetColumnNames< Currency          >( const QString &prefix )   { return modelsHelperStringToVector( generateFieldName(prefix,"ID"), generateFieldName(prefix,"NAME"      ) , generateFieldName(prefix,"DESCRIPTION") ); }
template< > inline QVector<QString> modelTableGetColumnNames< InstrumentType    >( const QString &prefix )   { return modelsHelperStringToVector( generateFieldName(prefix,"ID"), generateFieldName(prefix,"TYPE"      ) , generateFieldName(prefix,"DESCRIPTION") ); }
template< > inline QVector<QString> modelTableGetColumnNames< CandleResolution  >( const QString &prefix )   { return modelsHelperStringToVector( generateFieldName(prefix,"ID"), generateFieldName(prefix,"RESOLUTION") , generateFieldName(prefix,"DESCRIPTION") ); }
template< > inline QVector<QString> modelTableGetColumnNames< OperationType     >( const QString &prefix )   { return modelsHelperStringToVector( generateFieldName(prefix,"ID"), generateFieldName(prefix,"TYPE"      ) , generateFieldName(prefix,"DESCRIPTION") ); }
template< > inline QVector<QString> modelTableGetColumnNames< OrderStatus       >( const QString &prefix )   { return modelsHelperStringToVector( generateFieldName(prefix,"ID"), generateFieldName(prefix,"STATUS"    ) , generateFieldName(prefix,"DESCRIPTION") ); }
template< > inline QVector<QString> modelTableGetColumnNames< OrderType         >( const QString &prefix )   { return modelsHelperStringToVector( generateFieldName(prefix,"ID"), generateFieldName(prefix,"TYPE"      ) , generateFieldName(prefix,"DESCRIPTION") ); }

//----------------------------------------------------------------------------




//----------------------------------------------------------------------------
const std::size_t sqlFieldNameWidth = 34;

#define INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG()         QVector<QString> resVec;  \
                                                                                            QString p = forInlining ? (nameOrPrefix.isEmpty() ? QString() : nameOrPrefix + QString("_")) : QString()

#define INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND_IMPL( wht )         appendToStringVector( resVec, wht )

#define INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND( wht )              appendToStringVector( resVec, wht )

#define INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( whtName, whtSql )                               \
               INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND_IMPL(                                      \
                        QString::fromStdWString(cpp::expandAtBack( generateFieldName(p, whtName).toStdWString(), sqlFieldNameWidth))    \
                      + QString(" ")                                                                                                    \
                      + QString(whtSql)                                                                                                 \
                                                                                                 )

#define INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG() return resVec

#define INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_BEGIN() if (forInlining) {
#define INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_ELSE()  } else {
#define INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_END()   }


//----------------------------------------------------------------------------
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE<BrokerAccountType>( const QString &nameOrPrefix, bool forInlining )
{
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_BEGIN()
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"         , "INTEGER REFERENCES BROKER_ACCOUNT_TYPE" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TYPE"       , "VARCHAR(10) NOT NULL" );
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_ELSE()
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"         , "INTEGER PRIMARY KEY" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TYPE"       , "VARCHAR(10) NOT NULL UNIQUE" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "DESCRIPTION", "VARCHAR(255)" );
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_END()

    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();

    // return modelsHelperStringToVector( cpp::expandAtBack(nameOrPrefix.toStdString(),24) + cpp::expandAtBack("VARCHAR(12)",16) );
}

//----------------------------------------------------------------------------
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE<Currency>( const QString &nameOrPrefix, bool forInlining )
{
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_BEGIN()
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"         , "INTEGER REFERENCES CURRENCY" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "NAME"       , "VARCHAR(8) NOT NULL" );
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_ELSE()
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"         , "INTEGER PRIMARY KEY" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "NAME"       , "VARCHAR(8) NOT NULL UNIQUE" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "DESCRIPTION", "VARCHAR(255)" );
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_END()

    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();

    // return modelsHelperStringToVector( cpp::expandAtBack(nameOrPrefix.toStdString(),24) + cpp::expandAtBack("VARCHAR(4) NOT NULL",16) ); // UNIQUE
}

//----------------------------------------------------------------------------
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE<InstrumentType>( const QString &nameOrPrefix, bool forInlining )
{
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_BEGIN()
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"         , "INTEGER REFERENCES INSTRUMENT_TYPE" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TYPE"       , "VARCHAR(8) NOT NULL" );
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_ELSE()
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"         , "INTEGER PRIMARY KEY" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TYPE"       , "VARCHAR(8) NOT NULL UNIQUE" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "DESCRIPTION", "VARCHAR(255)" );
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_END()

    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();

    // return modelsHelperStringToVector( cpp::expandAtBack(nameOrPrefix.toStdString(),24) + cpp::expandAtBack("VARCHAR(12) NOT NULL",16) );
}

//----------------------------------------------------------------------------
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE<CandleResolution>( const QString &nameOrPrefix, bool forInlining )
{
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_BEGIN()
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"         , "INTEGER REFERENCES CANDLE_RESOLUTION" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "RESOLUTION" , "VARCHAR(8) NOT NULL" );
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_ELSE()
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"         , "INTEGER PRIMARY KEY" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "RESOLUTION" , "VARCHAR(8) NOT NULL UNIQUE" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "DESCRIPTION", "VARCHAR(255)" );
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_END()

    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();

    // return modelsHelperStringToVector( cpp::expandAtBack(nameOrPrefix.toStdString(),24) + cpp::expandAtBack("HIJACK",16) );
}

//----------------------------------------------------------------------------
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE<OperationType>( const QString &nameOrPrefix, bool forInlining )
{
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_BEGIN()
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"         , "INTEGER REFERENCES OPERATION_TYPE" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TYPE"       , "VARCHAR(8) NOT NULL" );
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_ELSE()
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"         , "INTEGER PRIMARY KEY" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TYPE"       , "VARCHAR(8) NOT NULL UNIQUE" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "DESCRIPTION", "VARCHAR(255)" );
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_END()

    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();

    // return modelsHelperStringToVector( cpp::expandAtBack(nameOrPrefix.toStdString(),24) + cpp::expandAtBack("HIJACK",16) );
}

//----------------------------------------------------------------------------
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE<OrderStatus>( const QString &nameOrPrefix, bool forInlining )
{
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_BEGIN()
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"         , "INTEGER REFERENCES ORDER_STATUS" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "STATUS"     , "VARCHAR(14) NOT NULL" );
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_ELSE()
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"         , "INTEGER PRIMARY KEY" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "STATUS"     , "VARCHAR(14) NOT NULL UNIQUE" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "DESCRIPTION", "VARCHAR(255)" );
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_END()

    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();

    // return modelsHelperStringToVector( cpp::expandAtBack(nameOrPrefix.toStdString(),24) + cpp::expandAtBack("HIJACK",16) );
}

//----------------------------------------------------------------------------
template <> inline QVector<QString> modelMakeSqlSchemaStringVector_SQLITE<OrderType>( const QString &nameOrPrefix, bool forInlining )
{
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_PROLOG();

    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_BEGIN()
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"         , "INTEGER REFERENCES ORDER_STATUS" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TYPE"       , "VARCHAR(8) NOT NULL" );
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_ELSE()
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "ID"         , "INTEGER PRIMARY KEY" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "TYPE"       , "VARCHAR(8) NOT NULL UNIQUE" );
        INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_RES_APPEND2( "DESCRIPTION", "VARCHAR(255)" );
    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_INLINING_END()

    INVEST_OPEAPI_MODEL_TO_STRINGS_MODEL_MAKE_SQL_SCHEMA_STRING_VECTOR_EPILOG();

    // return modelsHelperStringToVector( cpp::expandAtBack(nameOrPrefix.toStdString(),24) + cpp::expandAtBack("HIJACK",16) );
}

//----------------------------------------------------------------------------




//----------------------------------------------------------------------------

} // namespace invest_openapi


#include "model_to_strings_generated_SQLITE.h"


